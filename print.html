<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MacroKata</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html">00: Introduction</a></li><li class="chapter-item expanded "><a href="01_README.html">01: My First Macro</a></li><li class="chapter-item expanded "><a href="02_README.html">02: Numbers</a></li><li class="chapter-item expanded "><a href="03_README.html">03: Literal Meta-Variables</a></li><li class="chapter-item expanded "><a href="04_README.html">04: Expression Meta-Variables</a></li><li class="chapter-item expanded "><a href="05_README.html">05: More Complex Example</a></li><li class="chapter-item expanded "><a href="06_README.html">06: Repetition</a></li><li class="chapter-item expanded "><a href="07_README.html">07: More Repetition</a></li><li class="chapter-item expanded "><a href="08_README.html">08: Nested Repetition</a></li><li class="chapter-item expanded "><a href="09_README.html">09: Ambiguity and Ordering</a></li><li class="chapter-item expanded "><a href="10_README.html">10: Macros Calling Macros</a></li><li class="chapter-item expanded "><a href="11_README.html">11: Macro Recursion</a></li><li class="chapter-item expanded "><a href="12_README.html">12: Macro Hygiene</a></li><li class="chapter-item expanded "><a href="13_README.html">13: Scoping, Importing and Exporting</a></li><li class="chapter-item expanded "><a href="99_README.html">14: Extra Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MacroKata</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="macrokata"><a class="header" href="#macrokata">MacroKata</a></h1>
<p>Welcome to MacroKata, a set of exercises which you can use to learn how to write
macros in rust. When completing each task, there are three goals:</p>
<ul>
<li>Get your code to compile without warnings or errors.</li>
<li>Get your code to &quot;work correctly&quot; (i.e. produce the same output)</li>
<li>Importantly, <em>generate the same code</em> as what the sample solution does.</li>
</ul>
<p>You should complete the kata in order, as they increase in
difficulty, and depend on previous kata. </p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Clone this repository:</p>
<pre><code class="language-sh">$ git clone https://www.github.com/tfpk/macrokata/
</code></pre>
<p>You will also need to install the rust &quot;nightly&quot; toolchain, so that we can show
expanded macros.</p>
<pre><code class="language-sh">$ rustup toolchain install nightly
</code></pre>
<p>And install cargo expand.</p>
<pre><code class="language-sh">$ cargo install cargo-expand
</code></pre>
<p>Build the main binary provided with this repo:</p>
<pre><code class="language-sh">$ cargo build --bin macrokata
</code></pre>
<p>You can find the first kata (<code>my_first_macro</code>) inside <code>tasks/01_my_first_macro</code>.
Read the <code>README.md</code> file, and get started by editing the <code>main.rs</code> file.</p>
<p>To compare your expanded code to the &quot;goal&quot;; use the <code>test</code> subcommand.</p>
<pre><code class="language-sh">$ cargo run -- test 01_my_first_macro
</code></pre>
<p>To run your own code, use:</p>
<pre><code class="language-sh">$ cargo run --bin 01_my_first_macro
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-1-my-first-macro"><a class="header" href="#exercise-1-my-first-macro">Exercise 1: My First Macro</a></h1>
<p>Welcome to this introduction to Rust's Macro system.
To complete each exercise (including this one), you should:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Read this file to understand the theory being tested, and what
task you will be asked to complete.</li>
<li><input disabled="" type="checkbox"/>
Try and complete the <code>main.rs</code> file.</li>
<li><input disabled="" type="checkbox"/>
Test to see if your macro creates the same code we have; using
<code>cargo run -- test 01_my_first_macro</code>.</li>
<li><input disabled="" type="checkbox"/>
Run your code, using <code>cargo run --bin 01_my_first_macro</code>, to see what it does.</li>
</ul>
<h2 id="what-are-macros"><a class="header" href="#what-are-macros">What are Macros?</a></h2>
<p>Rust's macros are a way of using code to generate code before compilation.
Because the generation happens before the compiler does anything; you are given
much more flexibility in what you can write.</p>
<p>This allows you to break many of the syntax rules rust imposes on you. For
example, Rust does not allow &quot;variadic&quot; functions -- functions with variable
numbers of arguments. This makes a <code>println</code> function impossible -- it would
have to take any number of arguments (<code>println!(&quot;hello&quot;)</code> and <code>println(&quot;{}&quot;, 123)</code>, for example).</p>
<p>Rust gets around this rule by using a <code>println!</code> macro. Before <code>println!</code> is
compiled, Rust rewrites the macro into a function which takes a single array of
arguments. That way, even though it looks to you like there are multiple
arguments, once it's compiled there's always just one array.</p>
<p>Macros can range from simple -- reducing duplicated code; to complex,
like implementing HTML parsing inside of Rust. This guide aims to build you up
from the simple to the complex.</p>
<p>As mentioned, you've already used macros -- <code>println!</code> for example, is a macro.
<code>vec![]</code> is as well. Macros always have a name. To run a macro, call it's name
with a bang (<code>!</code>) afterwards, and then brackets (any of <code>()</code>, <code>[]</code> or <code>{}</code>)
containing arguments.</p>
<p>In other words, to run the macro <code>my_macro</code>, you'd say <code>my_macro!()</code> or
<code>my_macro![]</code> or <code>my_macro!{}</code>.</p>
<h2 id="macro-rules-vs-procedural-macros"><a class="header" href="#macro-rules-vs-procedural-macros">Macro Rules vs. Procedural Macros</a></h2>
<p>Rust has two macros systems, but this guide will only focus on one.
<code>macro_rules!</code> are a special language to describe how to transform
code into valid rust code -- this is the system we will focus on.
Procedural macros (proc-macros) are a method of writing a rust function
which transforms an input piece of rust code into an output piece.</p>
<p>Proc Macros are useful, but complex, and not the subject of this guide.
<a href="https://doc.rust-lang.org/reference/procedural-macros.html">You can read more about them here</a></p>
<h2 id="how-do-i-create-one"><a class="header" href="#how-do-i-create-one">How do I create one?</a></h2>
<p>The simplest form of macro looks like this:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! my_macro {
    () =&gt; {
        3
    }
}

<span class="boring">fn main() {
</span>let _value = my_macro!();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>macro_rules!</code> instructs the compiler that there is a new macro you are
defining. It is followed by the name of the macro, <code>my_macro</code>. The next line
specifies a &quot;rule&quot;. Inside the normal brackets is a &quot;matcher&quot; -- some text
(formally, we refer to the text as &quot;tokens&quot;) which Rust will use to decide
which rule to execute. Inside the curly brackets is a &quot;transcriber&quot;, which is
what rust will replace <code>my_macro!()</code> with.</p>
<p>So, <code>my_macro!()</code> will be replaced by <code>3</code>.</p>
<h2 id="exercise-1-my-first-macro-1"><a class="header" href="#exercise-1-my-first-macro-1">Exercise 1: My First Macro</a></h2>
<p>Your task is to write a macro named <code>show_output!()</code> which calls the
<code>show_output()</code> function.</p>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    show_output()
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-2-numbers"><a class="header" href="#exercise-2-numbers">Exercise 2: Numbers</a></h1>
<p>As a reminder, to complete this exercise:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Read this file to understand the theory being tested, and what
task you will be asked to complete.</li>
<li><input disabled="" type="checkbox"/>
Try and complete the <code>main.rs</code> file.</li>
<li><input disabled="" type="checkbox"/>
Test to see if your macro creates the same code we have; using
<code>cargo run -- test 02_numbers</code>.</li>
<li><input disabled="" type="checkbox"/>
Run your code, using <code>cargo run --bin 02_numbers</code>, to see what it does.</li>
</ul>
<h2 id="macros-with-arguments"><a class="header" href="#macros-with-arguments">Macros With Arguments</a></h2>
<p>Macros would be pretty useless if you couldn't modify their behaviour based on
input from the programmer. To this end, let's see how we can vary what our macro
does.</p>
<p>The simplest way of doing this is to have our macro behave differently if
different tokens are placed in-between the matcher. As a reminder, the matcher
is the bit in each rule before the <code>=&gt;</code>.</p>
<p>Below we see a macro which will replace itself with <code>true</code> if the letter <code>t</code> is
inside the brackets; and <code>f</code> otherwise.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! torf {
    (t) =&gt; {
        true
    };
    (f) =&gt; {
        false
    };
}
<span class="boring">fn main() {
</span>let _true = torf!(t);
let _false = torf!(f);
<span class="boring">}
</span></code></pre></pre>
<p>You'll note the syntax has changed slightly -- we've gone from having one of the
<code>() =&gt; {}</code> blocks (which is called a rule), to having two. Macros try to find
the first rule that matches, and replaces the macro with the contents of the
transcriber block.</p>
<p>Macros are very similar to a <code>match</code> statement because they find the first match
and take action based on that; but it's important to note that you're not matching
on <em>variables</em>, you're matching on tokens.</p>
<h2 id="but-what-is-a-token"><a class="header" href="#but-what-is-a-token">But what is a &quot;token&quot;</a></h2>
<p>Up until now, we've spoken about &quot;tokens&quot;, without explaining what we mean
further than a handwavey &quot;it's text&quot;.</p>
<p>When Rust code is compiled, one of the first steps of parsing is turning bytes
of text into a &quot;token tree&quot;, which is a data-structure representing the
text-fragments of a line of code (so <code>(3 + (4 + 5))</code> becomes a token tree containing
<code>3</code>, <code>+</code> and another token tree containing <code>4</code>, <code>+</code> and <code>5</code>.</p>
<p>This means that macro matchers aren't restricted to matching exact text; and that
they preserve brackets when matching things.</p>
<p>As you've seen above, macros let you capture all the tokens inside their
brackets, and then modify the code the write back out based on those tokens.
This ability to react to different pieces of code without them having been fully
compiled lets us create powerful extensions to the rust language, using your own
syntax.</p>
<p>Further advanced reading about what tokens are can be found <a href="https://doc.rust-lang.org/reference/tokens.html">here</a></p>
<h2 id="exercise-2-numbers-1"><a class="header" href="#exercise-2-numbers-1">Exercise 2: Numbers</a></h2>
<p>Your task is to create a macro called <code>num</code> which replaces the words <code>one</code>, <code>two</code> and <code>three</code>
with the relevant numbers.</p>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    print_result(1 + 2 + 3);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-3-literal-meta-variables"><a class="header" href="#exercise-3-literal-meta-variables">Exercise 3: Literal Meta-Variables</a></h1>
<p>In the last exercise, we saw how we could change the behaviour of
a macro based on text inside the brackets. This is great, but it's
basically an if statement on the text inside the brackets -- it's
very simplistic.</p>
<p>Now we will introduce the concept of a &quot;metavariable&quot;. Metavariables capture a
particular part of the text inside the macro's brackets; and let you reuse it.</p>
<p>The syntax for a meta-variable is simple. To explain the syntax, see the example
below:</p>
<pre><code class="language-rust ignore">macro_rules! do_thing {
    (print $metavar:literal) =&gt; {
        println!(&quot;{}&quot;, $metavar)
    };
}
</code></pre>
<p>The <code>$metavar:literal</code> is saying that you're capturing any <code>literal</code> (which is
something like <code>'a'</code>, or <code>3</code>, or <code>&quot;hello&quot;</code>), and naming it <code>metavar</code>. Then,
<code>$metavar</code> inside the <code>println!</code> is saying to &quot;fill in&quot; that space with whatever
<code>metavar</code> is.</p>
<p>For an invocation like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">macro_rules! do_thing {
</span><span class="boring">    (print $metavar:literal) =&gt; {
</span><span class="boring">        println!(&quot;{}&quot;, $metavar)
</span><span class="boring">    };
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>do_thing!(print 3);
<span class="boring">}
</span></code></pre></pre>
<p>Rust understands that <code>metavar</code> means <code>3</code>. So, when doing substitution,
it starts by writing:</p>
<pre><code class="language-rust ignore">println!(&quot;{}&quot;, $metavar);
</code></pre>
<p>And then substitutes <code>3</code> for <code>$metavar</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 3);
<span class="boring">}
</span></code></pre></pre>
<h2 id="but-what-about-types"><a class="header" href="#but-what-about-types">But what about types?</a></h2>
<p>You might be wondering why we haven't said anything about the <em>type</em> of the
literal. It turns out, the type doesn't matter during macro expansion. Rather
than needing the type, Rust just needs to know what sort of syntax to expect. If
you tried to provide a variable name, and you needed a literal, Rust will throw
an error. If you needed a <em>string</em> literal, and you provided a <em>char</em> literal,
then rust will happily expand the code. It'll throw an error later on in the
compilation process; as if you had written the expanded code.</p>
<h2 id="why-do-these-examples-avoid-using-macros"><a class="header" href="#why-do-these-examples-avoid-using-macros">Why do these examples avoid using macros?</a></h2>
<p>The example above uses the <code>println!</code> macro inside the <code>print_me</code>
macro. Rust is totally fine with this! However, <code>macrokata</code> tries 
to avoid (as much as possible) using macros we didn't define inside
the main function. The reason for this is that, if we did use <code>println!</code>
you would see it's expansion as well. That could be confusing, since:</p>
<pre><code class="language-rust ignore">print(&quot;some text&quot;)
</code></pre>
<p>is much easier to read than:</p>
<pre><code class="language-rust ignore">    {
        ::std::io::_print(
            ::core::fmt::Arguments::new_v1(
                &amp;[&quot;some text&quot;],
                &amp;[],
            ),
        );
    };

</code></pre>
<h2 id="exercise-3-literal-meta-variables-1"><a class="header" href="#exercise-3-literal-meta-variables-1">Exercise 3: Literal Meta-Variables</a></h2>
<p>Your task is to create a macro which can perform two small bits of math:</p>
<ul>
<li>The syntax <code>math!(3 plus 5)</code> should expand to <code>3 + 5</code>, where <code>3</code> and <code>5</code>
could be any literal.</li>
<li>The syntax <code>math!(square 2)</code> should expand to <code>2 * 2</code>, where <code>2</code> could be any
literal.</li>
</ul>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    print_result(3 + 5);
    print_result(2 * 2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-4-expression-metavariables"><a class="header" href="#exercise-4-expression-metavariables">Exercise 4: Expression Metavariables</a></h1>
<p>We can now capture fragments of Rust code that are literals, however there are
other fragments of rust code which can be captured in metavariables. In general,
every metavariable is of the form <code>$&lt;NAME&gt;:&lt;FRAGSPEC&gt;</code>. <code>&lt;NAME&gt;</code> is replaced
with the name of the metavariable; but <code>FRAGSPEC</code> is more interesting. It means
&quot;Fragment Specifier&quot;, and it tells you what sort of fragment of Rust code you
intend to match. We've already seen <code>literal</code>, but another common fragment
specifier is <code>expr</code>, which allows you to capture any rust expression (for
example, <code>(3 * 5)</code> or <code>function_call() + CONSTANT</code>).</p>
<p>Using this specifier is nearly identical to using the <code>literal</code> fragment
specifier -- <code>$x:expr</code> indicates a metavariable, which is an expression, named
<code>x</code>.</p>
<p>It's also worth mentioning the fragment specifier <code>stmt</code>, which is similar to
<code>expr</code>, but allows Rust statements too, like <code>let</code> statements.</p>
<h1 id="macros-and-the-precedence-of-operators"><a class="header" href="#macros-and-the-precedence-of-operators">Macros and the Precedence of Operators</a></h1>
<p>Macros do not affect the order of operations. If the expression <code>3 * math!(4, plus, 2)</code> expands to <code>3 * 4 + 2</code>; the answer will be 14, not 18 (as you might
expect from the brackets).</p>
<h1 id="follow-set-ambiguity-rules"><a class="header" href="#follow-set-ambiguity-rules">&quot;Follow-set Ambiguity Rules&quot;</a></h1>
<p>The rust parser needs to have some way of telling &quot;where does a metavariable
end&quot;. If it didn't, expressions like <code>$first:expr $second:expr</code> would be confusing to
parse in some circumstances (for example, how would you parse <code>a * b * c * d</code>?
Would <code>first</code> be <code>a</code>, and <code>second</code> be <code>*b * c * d</code>? Or would <code>first</code> be <code>a * b * c</code>,
and <code>second</code> be <code>* d</code>?</p>
<p>To avoid this problem entirely, Rust has a set of rules called the &quot;follow-set
ambiguity rules&quot;. These tell you which tokens are allowed to follow a
metavariable (and which aren't).</p>
<p>For <code>literal</code>s, this rule is simple -- anything can follow a literal
metavariable.</p>
<p>For <code>expr</code> (and it's friend <code>stmt</code>) the rules are much more restrictive -- they
can only be followed by <code>=&gt;</code> or <code>,</code> or <code>;</code>.</p>
<p>This means that building a matcher like this:</p>
<pre><code class="language-rust ignore">macro_rules! broken_macro {
    ($a:expr please) =&gt; $a
}

fn main() {
    // Fails to compile!
    let value = broken_macro!(3 + 5 please);
}
</code></pre>
<p>will give you this compiler error:</p>
<pre><code class="language-rust ignore">error: `$a:expr` is followed by `please`, which is not allowed for `expr` fragments
 --&gt; broken_macro.rs:2:14
  |
2 |     ($a:expr please) =&gt; { $a }
  |              ^^^^^^ not allowed after `expr` fragments
  |
  = note: allowed there are: `=&gt;`, `,` or `;`
</code></pre>
<p>As we encounter more expression types, we'll make sure to mention their
follow-set rules; but <a href="https://doc.rust-lang.org/reference/macros-by-example.html#follow-set-ambiguity-restrictions">this page in the Rust
reference</a>
has a comprehensive list of the rules for each fragment specifier type.</p>
<h2 id="exercise-4-expression-variables"><a class="header" href="#exercise-4-expression-variables">Exercise 4: Expression Variables</a></h2>
<p>In this task, you will be completing a similar task to the previous one.
Last time, your macro should have worked with any <em>literal</em>, but now we would
like a macro which works with any <em>expression</em>.</p>
<ul>
<li>The syntax <code>math!(3, plus, (5 + 6))</code> should expand to <code>3 + (5 + 6)</code>, where
<code>3</code> and <code>(5 + 6)</code> could be any expression.</li>
<li>The syntax <code>math!(square my_expression)</code> should expand to <code>my_expression * my_expression</code>, where <code>my_expression</code> could be any expression.</li>
</ul>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    let var = 5;
    print_result((2 * 3) + var);
    print_result(var * var);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-5-a-more-complex-example"><a class="header" href="#exercise-5-a-more-complex-example">Exercise 5: A More Complex Example</a></h1>
<p>In this task, we'll be implementing code to make the following syntax possible:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>for_2d!(row &lt;i32&gt; in 1..5, col &lt;i32&gt; in 2..7, {
    // code
});
<span class="boring">}
</span></code></pre>
<p>This code should translate to (ignoring extra curly braces):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>for row in 1..5 {
    let row: i32 = row;
    for col in 2..7 {
        let col: i32 = col;
        // code
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To complete this task, there more fragment specifiers you will need to know
about:</p>
<ul>
<li><code>ident</code>: an &quot;identifier&quot;, like a variable name. <code>ident</code> metavariables
Can be followed by anything.</li>
<li><code>block</code>: a &quot;block expression&quot; (anything inside curly braces).
Can be followed by anything.</li>
<li><code>ty</code>: a type. Can only be followed by <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>,
<code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a <code>block</code> metavariable.</li>
</ul>
<p>As a reminder, you may not edit the <code>main</code> function; but it should eventually
look like the following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    for row in 1..5 {
        let row: i32 = row;
        for col in 2..7 {
            let col: i32 = col;
            { (Coordinate { x: col, y: row }).show() }
        }
    }
    let values = [1, 3, 5];
    for x in values {
        let x: u16 = x;
        for y in values {
            let y: u16 = y;
            {
                (Coordinate {
                    x: x.into(),
                    y: y.into(),
                })
                    .show()
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-6-repetition"><a class="header" href="#exercise-6-repetition">Exercise 6: Repetition</a></h1>
<p>Hopefully, you're now feeling pretty confident with metavariables. But, one of
the first justifications we gave for macros was their ability to simulate
&quot;variadic&quot; functions (functions which have a variable number of arguments). In
this exercise, we'll have a look at how you can implement them yourself.</p>
<p>A simple approach might be to write a rule for each number of arguments; for
example:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! listing_literals {
    (the $e1:literal) =&gt; {
        {
            let mut my_vec = Vec::new();
            my_vec.push($e1);
            my_vec
        }
    };
    (the $e1:literal and the $e2:literal) =&gt; {
        {
            let mut my_vec = Vec::new();
            my_vec.push($e1);
            my_vec.push($e2);
            my_vec
        }
    };
    (the $e1:literal and the $e2:literal and the $e3:literal) =&gt; {
        {
            let mut my_vec = Vec::new();
            my_vec.push($e1);
            my_vec.push($e2);
            my_vec.push($e3);
            my_vec
        }
    }
}

fn main() {
    let vec: Vec&lt;&amp;str&gt; = listing_literals!(the &quot;lion&quot; and the &quot;witch&quot; and the &quot;wardrobe&quot;);
    assert_eq!(vec, vec![&quot;lion&quot;, &quot;witch&quot;, &quot;wardrobe&quot;]);
    let vec: Vec&lt;i32&gt; = listing_literals!(the 9 and the 5);
    assert_eq!(vec, vec![9, 5]);
}
</code></pre></pre>
<p>This is very clunky, and involves a large amount of repeated code. Imagine doing
this for 10 arguments! What if we could say that we want <em>a variable number</em> of
a particular patterns. That would let us say &quot;give me any number of <code>$e:expr</code>
tokens, and I'll tell you what to do with them'&quot;.</p>
<p>Macro repetitions let us do just that. They consist of three things:</p>
<ul>
<li>a group of tokens that we want to match repeatedly.</li>
<li>optionally, a separator token (which tells the parser what to look for between each match)</li>
<li>either <code>+</code>, <code>*</code> or <code>?</code>; which says how many times to expect a match. <code>+</code> means &quot;at least once&quot;.
<code>*</code> means &quot;any number of times, including 0 times&quot;. <code>?</code> means &quot;either 0 times, or 1 time&quot;.</li>
</ul>
<p>Let's look at an example of a macro repetition, to parse the exact macro
we showed above.</p>
<p>The matcher we would use for this is: <code>$(the $my_literal:literal)and+</code>.
To break that down:</p>
<ul>
<li><code>$(</code> means that we're starting a repetition.</li>
<li>Inside the brackets, <code>the $my_literal:literal</code> is the pattern we're matching . We'll match the exact text &quot;the&quot;, and then a literal token.</li>
<li>the <code>)</code> means that we're done describing the pattern to match.</li>
<li>the <code>and</code> is optional, but it is the &quot;separator&quot; -- a token you can use to seperate multiple repetitions. Commonly it's <code>,</code> to comma-separate things. </li>
<li>Here, we use <code>+</code>, which means the repetition must happen at least once. <code>*</code> would have worked just as well if we were okay with an empty <code>Vec</code>.</li>
</ul>
<p>What's now left is to use the matched values. To do this, the rule would be something like:</p>
<pre><code class="language-rust ignore"> $(the $my_literal:literal)and+ =&gt; {
    {
        let mut my_vec = Vec::new();
        $(my_vec.push($my_literal));+;
        my_vec
    }
}
</code></pre>
<p>The line <code>$(my_vec.push($my_literal));+;</code> is nearly identical to the repetition we saw above, but to break it down:</p>
<ul>
<li><code>$(</code> tells us that we're starting a repetition.</li>
<li><code>my_vec.push($my_literal)</code> is the code that will be transcribed. <code>$my_literal</code> will be replaced with each of the literals specified in the matcher.</li>
<li>The <code>)</code> means that we're done describing the code that will be transcribed.</li>
<li>The <code>;</code> means we're separating these lines with semicolons</li>
<li>The <code>+</code> ends the repetition.</li>
<li>The <code>;</code> adds a final semicolon after the expansion of everything.</li>
</ul>
<p>So this will expand into the same code we saw above!</p>
<p>It's worth noting that we've used an extra set of curly braces in our transcriber. This is because if you don't
put the code in a block, the code will look like <code>let whatever = let mut my_vec = Vec::new();</code>, which doesn't make sense.</p>
<p>If you put the code in a curly brace, then the right-hand side of the <code>=</code> sign will be a block which returns <code>my_vec</code>.</p>
<h2 id="exercise-6-repetition-1"><a class="header" href="#exercise-6-repetition-1">Exercise 6: Repetition</a></h2>
<p>In this task, you will be creating an <code>if_any!</code> macro. If any of the first arguments are true,
it should execute the block which is the last argument.</p>
<p>You may not edit the <code>main</code> function; but once you have completed the exercise, your <code>if_any!</code> macro should expand to look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    if (false || 0 == 1 || true) {
        print_success();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-7-more-repetition"><a class="header" href="#exercise-7-more-repetition">Exercise 7: More Repetition</a></h1>
<p>This exercise is going to also cover writing repetitions, but now involving more than
one metavariable. Don't worry -- the syntax is the exact same as what you've seen before.</p>
<p>Before you start, let's just quickly cover the different ways you can use a metavariable
within a repetition.</p>
<h2 id="multiple-metavariables-in-one-repetition"><a class="header" href="#multiple-metavariables-in-one-repetition">Multiple Metavariables in One Repetition</a></h2>
<p>You can indicate that two metavariables should be used in a single repetition.</p>
<p>For example, <code>( $($i:ident is $e:expr),+ )</code> would match <code>my_macro!(pi is 3.14, tau is 6.28)</code>. 
You would end up with <code>$i</code> having matched <code>pi</code> and <code>tau</code>; and <code>$e</code> having matched <code>3.14</code> and
<code>6.28</code>. </p>
<p>Any repetition in the transcriber can use <code>$i</code>, or <code>$e</code>, or both within the same repetition.
So a transcriber could be <code>$(let $i = $e;)+</code>; or <code>let product = $($e)*+</code></p>
<h2 id="one-metavariable-each-for-two-repetitions"><a class="header" href="#one-metavariable-each-for-two-repetitions">One Metavariable Each, For Two Repetitions</a></h2>
<p>Alternatively, you could specify two different repetitions, each containing their
own metavariable. For example, this program will construct two vecs.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! two_vecs {
    ($($vec1:expr),+; $($vec2:expr),+) =&gt; {
        {
            let mut vec1 = Vec::new();
            $(vec1.push($vec1);)+
            let mut vec2 = Vec::new();
            $(vec2.push($vec2);)+

            (vec1, vec2)
        }
    }
}

<span class="boring">fn main() {
</span>    let vecs = two_vecs!(1, 2, 3; 'a', 'b');
<span class="boring">}
</span></code></pre></pre>
<p>Importantly, with the above example, you have to be careful about using <code>$vec1</code>
and <code>$vec2</code> in the same repetition within the transcriber. It is a compiler
error to use two metavariables captured a different number of times in the same
repetition.</p>
<p>To quote <a href="https://doc.rust-lang.org/reference/macros-by-example.html#transcribing">the reference</a>:</p>
<blockquote>
<p>Each repetition in the transcriber must contain at least one metavariable to
decide how many times to expand it. If multiple metavariables appear in the
same repetition, they must be bound to the same number of fragments. For
instance, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code> must
bind the same number of <code>$i</code> fragments as <code>$j</code> fragments. This means that invoking
the macro with <code>(a, b, c; d, e, f)</code> is legal and expands to <code>((a,d), (b,e), (c,f))</code>,
but <code>(a, b, c; d, e)</code> is illegal because it does not have the same
number. </p>
</blockquote>
<h2 id="exercise-7-more-repetition-1"><a class="header" href="#exercise-7-more-repetition-1">Exercise 7: More Repetition</a></h2>
<p>In this task, you will be creating a <code>hashmap</code> macro. It should consist
of comma-separated pairs, of the form <code>literal =&gt; expr,</code>
This should construct an empty <code>HashMap</code> and <code>insert</code> the
relevant key-value pairs.</p>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    let value = &quot;my_string&quot;;
    let my_hashmap = {
        let mut hm = HashMap::new();
        hm.insert(&quot;hash&quot;, &quot;map&quot;);
        hm.insert(&quot;Key&quot;, value);
        hm
    };
    print_hashmap(&amp;my_hashmap);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-8-nested-repetition"><a class="header" href="#exercise-8-nested-repetition">Exercise 8: Nested Repetition</a></h1>
<p>In this exercise, you will need to use nested repetition. That's where you
write a repetition inside another one, for example: <code>( $( $( $val:expr ),+ );+ )</code>
would let you specify at least one value, but seperate them with either <code>;</code> and <code>,</code>.</p>
<p>The only oddity about nested repetition is that you must ensure that you use
meta-variables in a context where it's clear you're only referring to one of them.
In other words, the <code>$val</code> metavariable in the last paragraph <em>must</em> be used within
a nested repetition.</p>
<h2 id="exercise-8-nested-repetition-1"><a class="header" href="#exercise-8-nested-repetition-1">Exercise 8: Nested Repetition</a></h2>
<p>In this task, you will be building a macro to load a data structure with
an adjacency list from a graph. As a refresher, graphs are data-structures
that describe how different nodes are connected.</p>
<p>Each will be a literal, and you will be specifying, for each node,
which nodes it connects to. For example:</p>
<pre><code class="language-rust ignore">graph!{
    1 -&gt; (2, 3, 4, 5);
    2 -&gt; (1, 3);
    3 -&gt; (2);
    4 -&gt; ();
    5 -&gt; (1, 2, 3);
}
</code></pre>
<p>Should get translated into a <code>Vec</code> containing the pairs <code>(1, 2)</code>, <code>(1, 3)</code>, ... <code>(2, 1)</code>, ... <code>(5, 3)</code></p>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">#[allow(clippy::vec_init_then_push)]
fn main() {
    let my_graph = {
        let mut vec = Vec::new();
        vec.push((1, 2));
        vec.push((1, 3));
        vec.push((1, 4));
        vec.push((1, 5));
        vec.push((2, 1));
        vec.push((2, 3));
        vec.push((3, 2));
        vec.push((5, 1));
        vec.push((5, 2));
        vec.push((5, 3));
        vec
    };
    print_vec(&amp;my_graph);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-9-ambiguity-and-ordering"><a class="header" href="#exercise-9-ambiguity-and-ordering">Exercise 9: Ambiguity and Ordering</a></h1>
<p>Up until this point, we've mostly been dealing with macros with a single rule.
We saw earlier that macros can require more than one rule; but so far we've never
had ambiguity in which rule should be followed.</p>
<p>There are, however, multiple circumstances where rules could have ambiguity,
so it's important to understand how macros deal with that ambiguity.</p>
<p>The following is adapted from the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#transcribing">rust documentation on
macros</a>:</p>
<ul>
<li>
<p>When a macro is invoked (i.e. someone writes <code>my_macro!()</code>), the compiler
looks for a macro with that name, and tries each rule in turn.</p>
</li>
<li>
<p>To try a rule, it reads through each token in the parser in turn. There are
three possibilities:</p>
<ol>
<li>The token found matches the matcher. In this case, it keeps parsing the
next token. If there are no tokens left, and the matcher is complete, then
the rule matches.</li>
<li>The token found does not match the matcher. In this case, rust tries the
next rule. If there are no rules left, an error is raised as the macro
cannot be expanded.</li>
<li>The rule is ambiguous. In other words, it's not clear from <em>just this
token</em> what to do. If this happens, this is an error.</li>
</ol>
</li>
<li>
<p>If it finds a rule that matches the tokens inside the brackets; it starts
transcribing. <em>Once a match is found, no more rules are examined</em>.</p>
</li>
</ul>
<p>Let's have a look at some examples:</p>
<pre><code class="language-rust ignore">macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

<span class="boring">fn main() {
</span>ambiguity!(error); 
<span class="boring">}
</span></code></pre>
<p>This example fails because rust is not able to determine what <code>$j</code> should be just by looking at
the current token. If rust could look forward, it would see that <code>$j</code> must be followed by a <code>)</code>,
but it cannot; so it causes an error.</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ordering {
    ($j:expr) =&gt; { &quot;This was an expression&quot; };
    ($j:literal) =&gt; { &quot;This was a literal&quot; };
}

<span class="boring">fn main() {
</span>let expr1 = ordering!('a');  // =&gt; &quot;This was an expression&quot;.
let expr1 = ordering!(3 + 5);  // =&gt; &quot;This was an expression&quot;.
<span class="boring">}
</span></code></pre></pre>
<p>This example demonstrates an example where rust macros can behave strangely due to
ordering rules -- even though <code>literal</code> is a much stricter condition than <code>expr</code>,
because <code>literal</code>s are <code>expr</code>s; the first rule will always match.</p>
<h2 id="exercise-9-ambiguity-and-ordering-1"><a class="header" href="#exercise-9-ambiguity-and-ordering-1">Exercise 9: Ambiguity and Ordering</a></h2>
<p>This task is a little bit different to previous tasks -- we have given you 
a partially functional macro already; along with some invocations of that macro.</p>
<p>You should adjust the macro's rules and syntax to make sure that you 
achieve the correct behaviour without any ambiguity. </p>
<ul>
<li><code>sum!()</code> should sum together two or more expressions together.</li>
<li><code>get_number_type!()</code> should determine what sort of rust syntax is being used:
a positive literal; a negative literal; a block, or an expression.</li>
</ul>
<p>You may not edit the <code>main</code> function; but it should eventually look like the
following:</p>
<!-- If you can see this text, it means you're not looking at the book.   -->
<!-- Run the cargo command below (without `cmdrun`) to see the real code. -->
<pre><code class="language-rust ignore">fn main() {
    NumberType::PositiveNumber(5).show();
    NumberType::NegativeNumber(-5).show();
    #[allow(clippy::let_and_return)]
    NumberType::UnknownBecauseBlock({
            let x = 6;
            x
        })
        .show();
    NumberType::UnknownBecauseExpr(1 + 2 + 3 + 4).show();
    NumberType::UnknownBecauseExpr(3 + 5 - 1).show();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-10-macros-calling-macros"><a class="header" href="#exercise-10-macros-calling-macros">Exercise 10: Macros Calling Macros</a></h1>
<p>We briefly mentioned in a previous exercise that macros are able to call
other macros. In this exercise we will look at a brief example of that.
Before we do, there are three small notes we should mention:</p>
<h2 id="the-stringify-macro"><a class="header" href="#the-stringify-macro">The <code>stringify</code> macro</a></h2>
<p>The <code>stringify!</code> macro takes tokens and turns them into a <code>&amp;str</code> that
textually represents what those tokens are. For example, <code>stringify!(1 + 1)</code>
will become <code>&quot;1 + 1&quot;</code></p>
<h2 id="the-tt-fragment-specifier"><a class="header" href="#the-tt-fragment-specifier">The <code>tt</code> fragment specifier</a></h2>
<p>An important macro specifier which we have not, as of yet, discussed,
is the <code>tt</code> macro. This captures a &quot;Token Tree&quot;, which is any token,
or a group of tokens inside brackets. This is the most flexible
fragment specifier, because it imposes no meaning on what the captured
tokens might be. For example:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! stringify_number {
    (one) =&gt; {&quot;1&quot;};
    (two) =&gt; {&quot;2&quot;};
    ($tokens:tt) =&gt; { stringify!($tokens)};
}

<span class="boring">fn main() {
</span>stringify_number!(one); // is &quot;1&quot;
stringify_number!(while); // is &quot;while&quot;
stringify_number!(bing_bang_boom); // is &quot;bing_bang_boom&quot;
<span class="boring">}
</span></code></pre></pre>
<p>It's really important to keep in mind with <code>tt</code> macros that you <strong>must</strong>
ensure that anything after them can be unambiguously parsed.</p>
<p>In other words, the metavariable <code>$($thing:tt)*</code> (ending with <code>*</code>, <code>+</code> OR <code>?</code>) <em>must</em>
be the last fragment in the parser. Since anything can be a token-tree, Rust could
not know what to accept after that parser.</p>
<p>To avoid this issue, you can either match a single <code>tt</code>, and make the user wrap multiple tokens
inside brackets; or you can specify a delimiter for your match (i.e. <code>$($thing:tt),+</code>, since
two token-trees not separated by a <code>,</code> could not match).</p>
<h2 id="restrictions-on-forwarding-macros"><a class="header" href="#restrictions-on-forwarding-macros">Restrictions on &quot;Forwarding Macros&quot;</a></h2>
<p>There is one important restriction when calling a macro using another macro:</p>
<p>When forwarding a matched fragment to another macro-by-example, matchers in the
second macro will see an opaque AST of the fragment type. The second macro can't
use literal tokens to match the fragments in the matcher, only a fragment
specifier of the same type. The <code>ident</code>, <code>lifetime</code>, and <code>tt</code> fragment types are an
exception, and <em>can</em> be matched by literal tokens. The following illustrates this
restriction:</p>
<pre><code class="language-rust ignore">macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro_rules! bar {
    (3) =&gt; {}
}

<span class="boring">fn main() {
</span>foo!(3);
<span class="boring">}
</span></code></pre>
<p>The following illustrates how tokens can be directly matched after matching a <code>tt</code> fragment:</p>
<pre><pre class="playground"><code class="language-rust">// compiles OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

<span class="boring">fn main() {
</span>foo!(3);
<span class="boring">}
</span></code></pre></pre>
<h2 id="exercise-10-macros-calling-macros-1"><a class="header" href="#exercise-10-macros-calling-macros-1">Exercise 10: Macros Calling Macros</a></h2>
<p>This exercise is similar to the one you completed earlier, building a
<code>hashmap!</code> macro; note that there are some subtle differences.</p>
<p>You are being asked to implement two macros -- <code>pair!()</code>, and <code>hashmap!()</code>.
The first should take two expressions separated by a <code>=&gt;</code>, and return a tuple of them.
The second should construct an array of those tuples, and use <code>HashMap::from</code> to
collect them into a <code>HashMap</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-11-macro-recursion"><a class="header" href="#exercise-11-macro-recursion">Exercise 11: Macro Recursion</a></h1>
<p>This exercise is a sort of culmination of everything you've learned so far about macros.</p>
<p>To complete it, you'll need to note one important fact -- macros can recurse into themselves.</p>
<p>This allows very powerful expansions. As a simple example:</p>
<pre><pre class="playground"><code class="language-rust">
enum LinkedList {
    Node(i32, Box&lt;LinkedList&gt;),
    Empty
}

macro_rules! linked_list {
    () =&gt; {
        LinkedList::Empty
    };
    ($expr:expr $(, $exprs:expr)*) =&gt; {
        LinkedList::Node($expr, Box::new(linked_list!($($exprs),*)))
    }
}

fn main() {
    let my_list = linked_list!(3, 4, 5);
}
</code></pre></pre>
<p>The above example is very typical. The first rule is the &quot;base case&quot; -- an empty
list of tokens implies an empty linked list.</p>
<p>The second rule always matches one expression first (<code>expr</code>). This allows us
to refer to it on its own, in this case to create the <code>Node</code>. The rest of
the expressions (<code>exprs</code>) are stored in a repetition; and all we'll do with
them is recurse into <code>linked_list!()</code>. If there's no expressions left,
that call to <code>linked_list!()</code> will give back <code>Empty</code>; otherwise it'll
repeat the same process.</p>
<p>While Macro Recursion is incredibly powerful; it is also slow. As a result,
there is a limit to the amount of recursion you are allowed to do. 
In rustc, the limit is <code>128</code>; but you can configure it with 
<code>#![recursion_limit = &quot;256&quot;]</code> as a crate level attribute.</p>
<h2 id="exercise-11-currying"><a class="header" href="#exercise-11-currying">Exercise 11: Currying</a></h2>
<p>Before you complete the exercise, let's briefly discuss a concept called &quot;currying&quot;.
If you're already familiar with the concept, perhaps from your own experience of
functional programming; you can skip the next two paragraphs.</p>
<p>In most imperative languages, the syntax to call a function with multiple arguments
is <code>function(arg1, arg2, arg3)</code>. If you do not provide all the arguments, that is 
an error. In many functional languages, however, the syntax for function calls is
more akin to <code>function(arg1)(arg2)(arg3)</code>. The advantage of this notation is that
if you specify less than the required number of arguments; it's not an error --
you get back a function that takes the rest of the arguments. A function that behaves
this way is said to be &quot;curried&quot; (named after Haskell Curry, a famous mathematician).</p>
<p>A good example of this is a curried <code>add</code> function. In regular Rust, we'd say <code>add</code> is <code>move |a, b| a + b</code>
is the add function. If we curried that function, we'd have add is <code>move |a| move |b| a + b</code>. What this
means is that we can write <code>let add_1 = add(1)</code>; and we now have a function which will
add 1 to anything.</p>
<p>In this exercise, you will build a macro which creates a curried function.
The syntax for this function will be <code>curry!((a: i32) =&gt; (b: i32) =&gt; _, {a + b})</code>.
Each pair of <code>ident: ty</code> is an argument; and the last <code>__</code> indicates that the
compiler will infer the return type. The block provided last is, of course,
the computation we want to do after receiving all the arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hygeine"><a class="header" href="#hygeine">Hygeine</a></h1>
<p>By default, all identifiers referred to in a macro are expanded as-is, and are
looked up at the macro's invocation site. This can lead to issues if a macro
refers to an item or macro which isn't in scope at the invocation site. To
alleviate this, the <code>$crate</code> metavariable can be used at the start of a path to
force lookup to occur inside the crate defining the macro.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>(based on the disclaimer for the brilliant
<a href="https://github.com/dtolnay/cargo-expand/">cargo-expand</a>)</p>
<p>Be aware that macro expansion to text is a lossy process. That means that the
expanded code we show in these kata should be used as a debugging aid only.
There should be no expectation that the expanded code can be compiled
successfully, nor that if it compiles then it behaves the same as the original
code. In these kata, we try to avoid these issues as far as possible.</p>
<p>For instance the following function returns <code>3</code> when compiled ordinarily by Rust
but the expanded code compiles and returns <code>4</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() -&gt; i32 {
    let x = 1;

    macro_rules! first_x {
        () =&gt; { x }
    }

    let x = 2;

    x + first_x!()
}
<span class="boring">}
</span></code></pre></pre>
<p>Refer to <a href="https://veykril.github.io/tlborm/decl-macros/minutiae/hygiene.html">The Little Book Of Rust Macros</a>
for more on the considerations around macro hygiene.</p>
<h2 id="exercise-12"><a class="header" href="#exercise-12">Exercise 12</a></h2>
<p>Exercise 12 consists of a file containing multiple modules. Fix the code so
that the macro works correctly in all invocations.</p>
<p>Note that you will need to use the <code>$crate</code> metavariable.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The subject of Scope, Import and Export are well covered
by the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#scoping-exporting-and-importing">Rust Reference</a>.</p>
<p>While practical example of these may be useful, this first verison of <code>macrokata</code> does not
include exercises for them. If you plan on using macros in a larger project, we suggest reading
the above reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extra-reading"><a class="header" href="#extra-reading">Extra Reading</a></h1>
<p>There are two excellent resources for further reading on Rust's 
macro system:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/macros.html">The Rust Reference</a>,</li>
<li><a href="https://veykril.github.io/tlborm/">The Little Book of Rust Macros</a> (note
that an older version exists, make sure you're reading this up-to-date one!)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
